typescriptreact
import React, { useState, useEffect } from 'react';
import { getProducts, addProduct, updateProduct, deleteProduct, Product, getProductsPaginated } from '../../firebase/firestore/productService';
import { collection, query, getDocs, orderBy, where, limit, startAfter, DocumentSnapshot } from 'firebase/firestore';
const ProductManagement: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  // State for the new product form
  const [newProductName, setNewProductName] = useState('');
  const [newProductDescription, setNewProductDescription] = useState('');
  const [newProductPrice, setNewProductPrice] = useState(0);
  const [newProductQuantity, setNewProductQuantity] = useState(0);
  // State for editing
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  // State for pagination
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [productsPerPage] = useState<number>(10); // Number of products per page
  const [lastVisible, setLastVisible] = useState<DocumentSnapshot | null>(null); // Store the last document snapshot for pagination
  // State for search
  const [searchTerm, setSearchTerm] = useState<string>('');

  useEffect(() => {
    const fetchProducts = async () => {
      setLoading(true);
      try {
        let productsQuery = query(collection(getProductsPaginated.db, "products"), orderBy("name")); // Assuming you want to order by name for pagination

        // Apply search filter if searchTerm is not empty
        if (searchTerm) {
          productsQuery = query(
            productsQuery,
            where("name", ">=", searchTerm),
            where("name", "<=", searchTerm + '\uf8ff') // Firestore range query for prefix matching
          );
        }

        // Apply pagination
        productsQuery = query(productsQuery, limit(productsPerPage));
        if (currentPage > 1 && lastVisible) {
            productsQuery = query(productsQuery, startAfter(lastVisible));
        }

        const querySnapshot = await getDocs(productsQuery);
        const productsData: Product[] = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as Product[];
        setProducts(productsData);
        setLastVisible(querySnapshot.docs.length > 0 ? querySnapshot.docs[querySnapshot.docs.length - 1] : null);
      } catch (error) {
        console.error("Error fetching products:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [currentPage, productsPerPage, lastVisible, searchTerm]); // Add pagination and search dependencies

  // Reset pagination when search term changes
  useEffect(() => { setCurrentPage(1); setLastVisible(null); }, [searchTerm]);

  const handleAddProduct = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!newProductName.trim() || newProductPrice <= 0 || newProductQuantity < 0) {
        alert('Please fill in all required fields and ensure price and quantity are valid.');
        return;
    }

    const newProduct: Product = {
        name: newProductName,
        description: newProductDescription,
        price: newProductPrice,
        quantity: newProductQuantity,
        // id will be generated by Firestore
    };

    try {
        await addProduct(newProduct);
        alert('Product added successfully!');
        // Clear the form
        setNewProductName('');
        setNewProductDescription('');
        setNewProductPrice(0);
        setNewProductQuantity(0);
        // Re-fetch products to update the list
        setCurrentPage(1); // Reset pagination on add
        setLastVisible(null);
    } catch (error) {
        console.error("Error adding product:", error);
        alert('Failed to add product.');
    }
  };

  const handleEditClick = (product: Product) => {
    setEditingProduct(product);
    setNewProductName(product.name);
    setNewProductDescription(product.description || ''); // Handle potential undefined description
    setNewProductPrice(product.price);
    setNewProductQuantity(product.quantity);
  };

  const handleCancelEdit = () => {
    setEditingProduct(null);
    setNewProductName('');
    setNewProductDescription('');
    setNewProductPrice(0);
    setNewProductQuantity(0);
  };

  const handleUpdateProduct = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!editingProduct || !newProductName.trim() || newProductPrice <= 0 || newProductQuantity < 0) {
        alert('Please fill in all required fields and ensure price and quantity are valid.');
        return;
    }

    const updatedProductData: Product = {
        id: editingProduct.id,
        name: newProductName,
        description: newProductDescription,
        price: newProductPrice,
        quantity: newProductQuantity,
    };

    try {
        await updateProduct(editingProduct.id!, updatedProductData);
        alert('Product updated successfully!');
        handleCancelEdit(); // Clear form and editing state
        fetchProducts(); // Re-fetch based on current pagination
        setCurrentPage(1); // Reset pagination on update
        setLastVisible(null);    } catch (error) {
        console.error("Error updating product:", error);
        alert('Failed to update product.');
    }
  };

  const handleDeleteProduct = async (productId: string) => {
    if (window.confirm('Are you sure you want to delete this product?')) {
      try {
        await deleteProduct(productId);
        alert('Product deleted successfully!');
        const updatedProducts = await getProducts(); // Re-fetch all after deletion for simplicity
        setCurrentPage(1); // Reset pagination on delete
        setLastVisible(null);      } catch (error) {
        console.error("Error deleting product:", error);
        alert('Failed to delete product.');
      }
    }
  };

  const handleNextPage = async () => {
    if (products.length > 0) {
      setCurrentPage(prevPage => prevPage + 1);
      setLastVisible(null); // Reset lastVisible to fetch next batch relative to current query
    }
  };

  const handlePreviousPage = () => {
    setCurrentPage(prevPage => Math.max(1, prevPage - 1));
    setLastVisible(null); // Reset lastVisible, will fetch first page again
  };
  return (
    < div >
      <h1>Product Management</h1>
      < div >
        < label htmlFor="productSearch" > Search by Name:</label >
        < input
          type="text"
          id="productSearch"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </ div >

      {loading ? (
        <p>Loading products...</p>
      ) : (
        <div>

          <h2>Product List</h2>
          <table>
            <thead>
              <tr>
                <th>Name</th>
                <th>Price</th>
                <th>Quantity</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {products.map((product) => (
                <tr key={product.id}>
                  <td>{product.name}</td>
                  <td>${product.price.toFixed(2)}</td>
                  <td>{product.quantity}</td>
                  {/* Check if product.id is defined before passing it to handleDeleteProduct */}
                  {product.id ? (
                    < td >
                      <button onClick={() => handleEditClick(product)}>Edit</button>
                      <button onClick={() => handleDeleteProduct(product.id)}>Delete</button>
                    </td>
                  ) : null
                }
              </tr>
            ))}
            </tbody>
          </table>
        </div>

      )}

      <h2>{editingProduct ? 'Edit Product' : 'Add New Product'}</h2>
      <form onSubmit={editingProduct ? handleUpdateProduct : handleAddProduct}>
        <div>
          <label htmlFor="newProductName">Name:</label>
          <input
            type="text"
            id="newProductName"
            value={newProductName}
            onChange={(e) => setNewProductName(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="newProductDescription">Description:</label>
          <textarea
            id="newProductDescription"
            value={newProductDescription}
            onChange={(e) => setNewProductDescription(e.target.value)}
          />
        </div>
        <div>
          <label htmlFor="newProductPrice">Price:</label>
          <input
            type="number"
            id="newProductPrice"
            value={newProductPrice}
            onChange={(e) => setNewProductPrice(parseFloat(e.target.value))}
            required
            min="0.01"
            step="0.01"
          />
        </div>
        <div>
          <label htmlFor="newProductQuantity">Quantity:</label>
          <input
            type="number"
            id="newProductQuantity"
            value={newProductQuantity}
            onChange={(e) => setNewProductQuantity(parseInt(e.target.value, 10))}
            required
            min="0"
          />
        </div>
        <button type="submit">{editingProduct ? 'Update Product' : 'Add Product'}</button>
        {editingProduct && (
          <button type="button" onClick={handleCancelEdit}>Cancel Edit</button>
        )}
      </form>
      <div>
        < button onClick={handlePreviousPage} disabled={currentPage === 1 || loading} > Previous</button >
        < button onClick={handleNextPage} disabled={loading || products.length < productsPerPage} > Next</button >
      </div>
    </div>
  );
};

export default ProductManagement;